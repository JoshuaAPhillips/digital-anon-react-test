"use strict";var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__hasOwnProp=Object.prototype.hasOwnProperty,__export=(e,t)=>{for(var r in t)__defProp(e,r,{get:t[r],enumerable:!0})},__copyProps=(e,t,r,n)=>{if(t&&"object"===typeof t||"function"===typeof t)for(let o of __getOwnPropNames(t))__hasOwnProp.call(e,o)||o===r||__defProp(e,o,{get:()=>t[o],enumerable:!(n=__getOwnPropDesc(t,o))||n.enumerable});return e},__toCommonJS=e=>__copyProps(__defProp({},"__esModule",{value:!0}),e),src_exports={};__export(src_exports,{createSelector:()=>createSelector,createSelectorCreator:()=>createSelectorCreator,createStructuredSelector:()=>createStructuredSelector,lruMemoize:()=>lruMemoize,referenceEqualityCheck:()=>referenceEqualityCheck,setGlobalDevModeChecks:()=>setGlobalDevModeChecks,unstable_autotrackMemoize:()=>autotrackMemoize,weakMapMemoize:()=>weakMapMemoize}),module.exports=__toCommonJS(src_exports);var runIdentityFunctionCheck=(e,t,r)=>{if(1===t.length&&t[0]===r){let t=!1;try{const r={};e(r)===r&&(t=!0)}catch{}if(t){let e;try{throw new Error}catch(n){({stack:e}=n)}console.warn("The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",{stack:e})}}},runInputStabilityCheck=(e,t,r)=>{const{memoize:n,memoizeOptions:o}=t,{inputSelectorResults:c,inputSelectorResultsCopy:a}=e,l=n((()=>({})),...o);if(!(l.apply(null,c)===l.apply(null,a))){let e;try{throw new Error}catch(s){({stack:e}=s)}console.warn("An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",{arguments:r,firstInputs:c,secondInputs:a,stack:e})}},globalDevModeChecks={inputStabilityCheck:"once",identityFunctionCheck:"once"},setGlobalDevModeChecks=e=>{Object.assign(globalDevModeChecks,e)},NOT_FOUND="NOT_FOUND";function assertIsFunction(e,t="expected a function, instead received "+typeof e){if("function"!==typeof e)throw new TypeError(t)}function assertIsObject(e,t="expected an object, instead received "+typeof e){if("object"!==typeof e)throw new TypeError(t)}function assertIsArrayOfFunctions(e,t="expected all items to be functions, instead received the following types: "){if(!e.every((e=>"function"===typeof e))){const r=e.map((e=>"function"===typeof e?`function ${e.name||"unnamed"}()`:typeof e)).join(", ");throw new TypeError(`${t}[${r}]`)}}var ensureIsArray=e=>Array.isArray(e)?e:[e];function getDependencies(e){const t=Array.isArray(e[0])?e[0]:e;return assertIsArrayOfFunctions(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}function collectInputSelectorResults(e,t){const r=[],{length:n}=e;for(let o=0;o<n;o++)r.push(e[o].apply(null,t));return r}var getDevModeChecksExecutionInfo=(e,t)=>{const{identityFunctionCheck:r,inputStabilityCheck:n}={...globalDevModeChecks,...t};return{identityFunctionCheck:{shouldRun:"always"===r||"once"===r&&e,run:runIdentityFunctionCheck},inputStabilityCheck:{shouldRun:"always"===n||"once"===n&&e,run:runInputStabilityCheck}}},$REVISION=0,CURRENT_TRACKER=null,Cell=class{revision=$REVISION;_value;_lastValue;_isEqual=tripleEq;constructor(e,t=tripleEq){this._value=this._lastValue=e,this._isEqual=t}get value(){return CURRENT_TRACKER?.add(this),this._value}set value(e){this.value!==e&&(this._value=e,this.revision=++$REVISION)}};function tripleEq(e,t){return e===t}var TrackingCache=class{_cachedValue;_cachedRevision=-1;_deps=[];hits=0;fn;constructor(e){this.fn=e}clear(){this._cachedValue=void 0,this._cachedRevision=-1,this._deps=[],this.hits=0}get value(){if(this.revision>this._cachedRevision){const{fn:e}=this,t=new Set,r=CURRENT_TRACKER;CURRENT_TRACKER=t,this._cachedValue=e(),CURRENT_TRACKER=r,this.hits++,this._deps=Array.from(t),this._cachedRevision=this.revision}return CURRENT_TRACKER?.add(this),this._cachedValue}get revision(){return Math.max(...this._deps.map((e=>e.revision)),0)}};function getValue(e){return e instanceof Cell||console.warn("Not a valid cell! ",e),e.value}function setValue(e,t){if(!(e instanceof Cell))throw new TypeError("setValue must be passed a tracked store created with `createStorage`.");e.value=e._lastValue=t}function createCell(e,t=tripleEq){return new Cell(e,t)}function createCache(e){return assertIsFunction(e,"the first parameter to `createCache` must be a function"),new TrackingCache(e)}var neverEq=(e,t)=>!1;function createTag(){return createCell(null,neverEq)}function dirtyTag(e,t){setValue(e,t)}var consumeCollection=e=>{let t=e.collectionTag;null===t&&(t=e.collectionTag=createTag()),getValue(t)},dirtyCollection=e=>{const t=e.collectionTag;null!==t&&dirtyTag(t,null)},REDUX_PROXY_LABEL=Symbol(),nextId=0,proto=Object.getPrototypeOf({}),ObjectTreeNode=class{constructor(e){this.value=e,this.value=e,this.tag.value=e}proxy=new Proxy(this,objectProxyHandler);tag=createTag();tags={};children={};collectionTag=null;id=nextId++},objectProxyHandler={get(e,t){return function(){const{value:r}=e,n=Reflect.get(r,t);if("symbol"===typeof t)return n;if(t in proto)return n;if("object"===typeof n&&null!==n){let r=e.children[t];return void 0===r&&(r=e.children[t]=createNode(n)),r.tag&&getValue(r.tag),r.proxy}{let r=e.tags[t];return void 0===r&&(r=e.tags[t]=createTag(),r.value=n),getValue(r),n}}()},ownKeys(e){return consumeCollection(e),Reflect.ownKeys(e.value)},getOwnPropertyDescriptor(e,t){return Reflect.getOwnPropertyDescriptor(e.value,t)},has(e,t){return Reflect.has(e.value,t)}},ArrayTreeNode=class{constructor(e){this.value=e,this.value=e,this.tag.value=e}proxy=new Proxy([this],arrayProxyHandler);tag=createTag();tags={};children={};collectionTag=null;id=nextId++},arrayProxyHandler={get([e],t){return"length"===t&&consumeCollection(e),objectProxyHandler.get(e,t)},ownKeys([e]){return objectProxyHandler.ownKeys(e)},getOwnPropertyDescriptor([e],t){return objectProxyHandler.getOwnPropertyDescriptor(e,t)},has([e],t){return objectProxyHandler.has(e,t)}};function createNode(e){return Array.isArray(e)?new ArrayTreeNode(e):new ObjectTreeNode(e)}function updateNode(e,t){const{value:r,tags:n,children:o}=e;if(e.value=t,Array.isArray(r)&&Array.isArray(t)&&r.length!==t.length)dirtyCollection(e);else if(r!==t){let n=0,o=0,c=!1;for(const e in r)n++;for(const e in t)if(o++,!(e in r)){c=!0;break}(c||n!==o)&&dirtyCollection(e)}for(const c in n){const o=r[c],a=t[c];o!==a&&(dirtyCollection(e),dirtyTag(n[c],a)),"object"===typeof a&&null!==a&&delete n[c]}for(const c in o){const e=o[c],r=t[c];e.value!==r&&("object"===typeof r&&null!==r?updateNode(e,r):(deleteNode(e),delete o[c]))}}function deleteNode(e){e.tag&&dirtyTag(e.tag,null),dirtyCollection(e);for(const t in e.tags)dirtyTag(e.tags[t],null);for(const t in e.children)deleteNode(e.children[t])}function createSingletonCache(e){let t;return{get(r){return t&&e(t.key,r)?t.value:NOT_FOUND},put(e,r){t={key:e,value:r}},getEntries(){return t?[t]:[]},clear(){t=void 0}}}function createLruCache(e,t){let r=[];function n(e){const n=r.findIndex((r=>t(e,r.key)));if(n>-1){const e=r[n];return n>0&&(r.splice(n,1),r.unshift(e)),e.value}return NOT_FOUND}return{get:n,put:function(t,o){n(t)===NOT_FOUND&&(r.unshift({key:t,value:o}),r.length>e&&r.pop())},getEntries:function(){return r},clear:function(){r=[]}}}var referenceEqualityCheck=(e,t)=>e===t;function createCacheKeyComparator(e){return function(t,r){if(null===t||null===r||t.length!==r.length)return!1;const{length:n}=t;for(let o=0;o<n;o++)if(!e(t[o],r[o]))return!1;return!0}}function lruMemoize(e,t){const r="object"===typeof t?t:{equalityCheck:t},{equalityCheck:n=referenceEqualityCheck,maxSize:o=1,resultEqualityCheck:c}=r,a=createCacheKeyComparator(n);let l=0;const s=1===o?createSingletonCache(a):createLruCache(o,a);function i(){let t=s.get(arguments);if(t===NOT_FOUND){if(t=e.apply(null,arguments),l++,c){const e=s.getEntries().find((e=>c(e.value,t)));e&&(t=e.value,0!==l&&l--)}s.put(arguments,t)}return t}return i.clearCache=()=>{s.clear(),i.resetResultsCount()},i.resultsCount=()=>l,i.resetResultsCount=()=>{l=0},i}function autotrackMemoize(e){const t=createNode([]);let r=null;const n=createCacheKeyComparator(referenceEqualityCheck),o=createCache((()=>e.apply(null,t.proxy)));function c(){return n(r,arguments)||(updateNode(t,arguments),r=arguments),o.value}return c.clearCache=()=>o.clear(),c}var StrongRef=class{constructor(e){this.value=e}deref(){return this.value}},Ref="undefined"!==typeof WeakRef?WeakRef:StrongRef,UNTERMINATED=0,TERMINATED=1;function createCacheNode(){return{s:UNTERMINATED,v:void 0,o:null,p:null}}function weakMapMemoize(e,t={}){let r=createCacheNode();const{resultEqualityCheck:n}=t;let o,c=0;function a(){let t=r;const{length:a}=arguments;for(let e=0,r=a;e<r;e++){const r=arguments[e];if("function"===typeof r||"object"===typeof r&&null!==r){let e=t.o;null===e&&(t.o=e=new WeakMap);const n=e.get(r);void 0===n?(t=createCacheNode(),e.set(r,t)):t=n}else{let e=t.p;null===e&&(t.p=e=new Map);const n=e.get(r);void 0===n?(t=createCacheNode(),e.set(r,t)):t=n}}const l=t;let s;if(t.s===TERMINATED?s=t.v:(s=e.apply(null,arguments),c++),l.s=TERMINATED,n){const e=o?.deref?.()??o;null!=e&&n(e,s)&&(s=e,0!==c&&c--);o="object"===typeof s&&null!==s||"function"===typeof s?new Ref(s):s}return l.v=s,s}return a.clearCache=()=>{r=createCacheNode(),a.resetResultsCount()},a.resultsCount=()=>c,a.resetResultsCount=()=>{c=0},a}function createSelectorCreator(e,...t){const r="function"===typeof e?{memoize:e,memoizeOptions:t}:e,n=(...e)=>{let t,n=0,o=0,c={},a=e.pop();"object"===typeof a&&(c=a,a=e.pop()),assertIsFunction(a,`createSelector expects an output function after the inputs, but received: [${typeof a}]`);const l={...r,...c},{memoize:s,memoizeOptions:i=[],argsMemoize:u=weakMapMemoize,argsMemoizeOptions:p=[],devModeChecks:d={}}=l,f=ensureIsArray(i),h=ensureIsArray(p),y=getDependencies(e),g=s((function(){return n++,a.apply(null,arguments)}),...f);let C=!0;const v=u((function(){o++;const e=collectInputSelectorResults(y,arguments);if(t=g.apply(null,e),"production"!==process.env.NODE_ENV){const{identityFunctionCheck:r,inputStabilityCheck:n}=getDevModeChecksExecutionInfo(C,d);if(r.shouldRun&&r.run(a,e,t),n.shouldRun){const t=collectInputSelectorResults(y,arguments);n.run({inputSelectorResults:e,inputSelectorResultsCopy:t},{memoize:s,memoizeOptions:f},arguments)}C&&(C=!1)}return t}),...h);return Object.assign(v,{resultFunc:a,memoizedResultFunc:g,dependencies:y,dependencyRecomputations:()=>o,resetDependencyRecomputations:()=>{o=0},lastResult:()=>t,recomputations:()=>n,resetRecomputations:()=>{n=0},memoize:s,argsMemoize:u})};return Object.assign(n,{withTypes:()=>n}),n}var createSelector=createSelectorCreator(weakMapMemoize),createStructuredSelector=Object.assign(((e,t=createSelector)=>{assertIsObject(e,"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a "+typeof e);const r=Object.keys(e);return t(r.map((t=>e[t])),((...e)=>e.reduce(((e,t,n)=>(e[r[n]]=t,e)),{})))}),{withTypes:()=>createStructuredSelector});